library(brms)
library(posterior)

Bayes_analysis <- function(int_data, m, bayes_model, int_t, target_n){
  # int_data is generated by generate_data()
  # It has one row per site opened at the point of interim analysis
  # y = number recruited; c = site ID; t = length of time site was open for
  # If no sites opened in time, a single row y=0, c=0, t=0 is returned
  # m is the number of sites to be opened over the whole trial
  # bayes_model is an object of class brmsfit - an "emppty" hierarchical 
  # model which we can use to generate posterior samples via brms::update().
  # Note that bayes_model includes the analysis prior pre-specification, and 
  # so may have to change for different scearios.
  
  # This function returns the statistic used by a Bayesian approach to making
  # progression decisions - the mean of the posterior (conditioning on the 
  # interim data) predictive distribution of the final recruit time
  
  n_p <- sum(int_data$y)
  m_p <- nrow(int_data)
  
  # Generate posterior samples
  output <- capture.output(fit <- suppressWarnings(update(bayes_model, 
                                                          recompile = FALSE, 
                                                          newdata = int_data, 
                                                          iter = 3000, 
                                                          warmup = 500,
                                                          control = list(adapt_delta = 0.95))))
  
  # Get vectors of posterior samples for the mean and SD parameters of the 
  # log-normal model for site recruitment rates
  s <- as_draws(fit)
  beta_0 <- extract_variable(s, "b_Intercept")
  sd_r <- extract_variable(s, "sd_c__Intercept")
  
  # First deal with cases where not all sites have yet opened
  if(m - m_p > 0){
    
    # Generate posterior samples of recruitment rates at all future sites,
    # Using the posterior samples of the log-normal recruitment rate model.
    # Each column of u is a yearly rate at that site, each row a sample from the 
    # posterior.
    us <- sapply(1:(m-m_p), function(x) exp(rnorm(length(beta_0), beta_0, sd_r)))
    
    # Add to that matrix the posterior samples for the sites which have already
    # opened
    r <- ranef(fit, summary = F)
    us <- cbind(us, exp(r$c[,1:m_p,1] + beta_0))
    
    # For site setup rates we have a simple conjugate analysis
    setup_r_a1 <- setup_r_a + m_p
    setup_r_b1 <- setup_r_b + int_t
    
    # We can then generate samples from the posterior of setup rate
    setup_rates <- rgamma(nrow(us), setup_r_a1, setup_r_b1)
    
    # Now sample actual site setup times from the posterior predictive
    setup_times <- t(sapply(setup_rates, function(x) cumsum(rexp(m-m_p, x))))
    
    # Add pilot sites using a setup time of 0
    setup_times <- cbind(setup_times, matrix(rep(0, m_p*nrow(us)), ncol = m_p))
    
    site_matrix <- cbind(us, setup_times)
    
    rec_times <- apply(site_matrix, 1, post_pred_rec_time, 
                       m=m, target_n=target_n)
    
    return(mean(rec_times))
  }
  
  # Bayes_analysis(int_data, 20, bayes_model, 0.5, 300)
}

post_pred_rec_time <- function(post_samples, m, target_n){
  # post_samples is a vector of one draw from the posterior distribution.
  # The first m elements are recruitment rates for the m sites; the next m 
  # elements are the corresponding opening times, relative to the interim 
  # analysis point.
  # Returns a sample time to hit recruitment target from the posterior
  # predictive distribution.
  
  end_rec <- 1000
  
  # Split up into the site rates and site setup times
  us <- post_samples[1:m]; setup_ts <- post_samples[(m+1):(2*m)]
  # Re-order each vector in order of site setup times
  us <- us[order(setup_ts)]; setup_ts <- setup_ts[order(setup_ts)]
  
  #################
  # Note - duplicating elements from the DGM function, need to tidy
  #################
  
  # Build a matrix of the recruitment periods with their start times, end
  # times, and overall recruitment rates
  rec_rates <- matrix(c(0, setup_ts,
                        setup_ts, end_rec,
                        0, cumsum(us)), ncol = 3)
  
  # Simulate numbers recruited in each period and add these as a column
  ## First get the vector of expected numbers recruited in each period
  exp_rec <- (rec_rates[,3]*(rec_rates[,2] - rec_rates[,1]))[2:(m+1)]
  ## Now sample from a Poisson for each period
  rec_rates <- cbind(rec_rates, c(0, rpois(m, exp_rec)))
  
  # Get time at which total target n is hit
  ## First get the period when it happens
  fin_period <- which(cumsum(rec_rates[,4]) > target_n)[1]
  ## Determine how many people need to arrive in that final period
  n_needed <- target_n - sum(rec_rates[1:(fin_period-1), 4])
  ## Simulate when the target is hit, which follows a gamma distribution
  rec_time <- rec_rates[fin_period, 1] + rgamma(1, shape = n_needed, rate = rec_rates[fin_period, 3])
  
  return(rec_time)
  
  # post_pred_rec_time(c(5,6,3, 0,0.5,1), 3, 200)
}
